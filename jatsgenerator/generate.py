from __future__ import print_function
import logging
import time
import os
from xml.etree.ElementTree import Element, SubElement, Comment
from xml.etree import ElementTree
from xml.dom import minidom
from elifetools import xmlio
from elifearticle import utils as eautils
from elifearticle.article import Article
import ejpcsvparser.parse as parse
from jatsgenerator.conf import raw_config, parse_raw_config
from jatsgenerator import utils

LOGGER = logging.getLogger('xml_gen')
HDLR = logging.FileHandler('xml_gen.log')
FORMATTER = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
HDLR.setFormatter(FORMATTER)
LOGGER.addHandler(HDLR)
LOGGER.setLevel(logging.INFO)


class ArticleXML(object):

    def __init__(self, poa_article, jats_config, add_comment=True):
        """
        set the root node
        get the article type from the object passed in to the class
        set default values for items that are boilder plate for this XML
        """
        if not isinstance(poa_article, Article):
            return

        # Set the config
        self.jats_config = jats_config
        # Create the root XML node
        self.root = Element('article')

        if poa_article.article_type:
            self.root.set('article-type', poa_article.article_type)
        self.root.set('xmlns:mml', 'http://www.w3.org/1998/Math/MathML')
        self.root.set('xmlns:xlink', 'http://www.w3.org/1999/xlink')
        self.root.set('dtd-version', '1.1d3')

        # set comment
        if add_comment:
            generated = time.strftime("%Y-%m-%d %H:%M:%S")
            last_commit = eautils.get_last_commit_to_master()
            comment = Comment('generated by ' + str(self.jats_config.get('generator')) +
                              ' at ' + generated +
                              ' from version ' + last_commit)
            self.root.append(comment)

        # contributor conflict count, incremented when printing contrib xref
        self.conflict_count = 0
        if poa_article.conflict_default:
            # conf1 is reserved for the default conflict value, so increment now
            self.conflict_count += 1

        # sec section counter
        self.sec_count = 0

        # dataset counter
        self.dataro_num = 0

        # corresponding author count, incremented when printing corresp xref
        self.corresp_count = 0

        # author aff count, and dict of author affiliations by index
        self.author_aff_count = 0
        self.author_affs = {}

        self.build(self.root, poa_article)

    def build(self, root, poa_article):
        self.set_frontmatter(root, poa_article)
        # self.set_title(self.root, poa_article)
        self.set_backmatter(root, poa_article)

    def set_frontmatter(self, parent, poa_article):
        front = SubElement(parent, 'front')
        self.set_journal_meta(front)
        self.set_article_meta(front, poa_article)
        return front

    def set_backmatter(self, parent, poa_article):
        back = SubElement(parent, 'back')
        info_sec = self.set_section(back, "additional-information")
        info_sec_title = SubElement(info_sec, "title")
        info_sec_title.text = "Additional information"
        if poa_article.has_contributor_conflict() or poa_article.conflict_default:
            self.set_fn_group_competing_interest(info_sec, poa_article)
        if poa_article.ethics:
            self.set_fn_group_ethics_information(info_sec, poa_article)
        if poa_article.datasets or poa_article.data_availability:
            supp_sec = self.set_section(back, "supplementary-material")
            supp_sec_title = SubElement(supp_sec, "title")
            supp_sec_title.text = "Additional Files"
            data_sec = self.set_section(supp_sec, "data-availability")
            self.set_article_datasets(data_sec, poa_article)

    def set_section(self, parent, sec_type):
        self.sec_count = self.sec_count + 1
        sec = SubElement(parent, "sec")
        sec.set("id", "s" + str(self.sec_count))
        sec.set("sec-type", sec_type)
        return sec

    def set_fn_group_competing_interest(self, parent, poa_article):
        competing_interest = SubElement(parent, "fn-group")
        competing_interest.set("content-type", "competing-interest")
        title = SubElement(competing_interest, "title")
        title.text = "Competing interest"

        # Check if we are supplied a conflict default statement and set count accordingly
        if poa_article.conflict_default:
            conflict_count = 1
        else:
            conflict_count = 0

        for contributor in poa_article.contributors:
            if contributor.conflict:
                for conflict in contributor.conflict:
                    conf_id = "conf" + str(conflict_count + 1)
                    fn_tag = SubElement(competing_interest, "fn")
                    fn_tag.set("fn-type", "conflict")
                    fn_tag.set("id", conf_id)
                    tag_name = 'p'
                    conflict_text = (contributor.given_name + " " + contributor.surname +
                                     ", " + conflict + ".")
                    utils.append_to_tag(fn_tag, tag_name, conflict_text)
                    # increment
                    conflict_count = conflict_count + 1
        if poa_article.conflict_default:
            # default for contributors with no conflicts
            if conflict_count > 1:
                # Change the default conflict text
                conflict_text = "The other authors declare that no competing interests exist."
            else:
                conflict_text = poa_article.conflict_default
            conf_id = "conf1"
            fn_tag = SubElement(competing_interest, "fn")
            fn_tag.set("fn-type", "conflict")
            fn_tag.set("id", conf_id)
            p_tag = SubElement(fn_tag, "p")
            p_tag.text = conflict_text
            conflict_count = conflict_count + 1

    def set_fn_group_ethics_information(self, parent, poa_article):
        ethics_fn_group = SubElement(parent, "fn-group")
        ethics_fn_group.set("content-type", "ethics-information")
        title = SubElement(ethics_fn_group, "title")
        title.text = "Ethics"

        for ethic in poa_article.ethics:
            fn_tag = SubElement(ethics_fn_group, "fn")
            fn_tag.set("fn-type", "other")
            p_tag = SubElement(fn_tag, "p")
            p_tag.text = ethic

    def set_article_meta(self, parent, poa_article):
        article_meta = SubElement(parent, "article-meta")

        # article-id pub-id-type="publisher-id"
        if poa_article.manuscript:
            pub_id_type = "publisher-id"
            article_id = SubElement(article_meta, "article-id")
            article_id.text = str(int(poa_article.manuscript)).zfill(5)
            article_id.set("pub-id-type", pub_id_type)

        # article-id pub-id-type="doi"
        if poa_article.doi:
            pub_id_type = "doi"
            article_id = SubElement(article_meta, "article-id")
            article_id.text = poa_article.doi
            article_id.set("pub-id-type", pub_id_type)

        # article-categories
        self.set_article_categories(article_meta, poa_article)

        self.set_title_group(article_meta, poa_article)

        for contrib_type in self.jats_config.get('contrib_types'):
            self.set_contrib_group(article_meta, poa_article, contrib_type)

        if bool([contrib for contrib in poa_article.contributors if contrib.corresp is True]):
            self.set_author_notes(article_meta, poa_article)

        self.set_pub_date(article_meta, poa_article, "pub")

        self.set_volume(article_meta, poa_article)

        if poa_article.manuscript:
            elocation_id = SubElement(article_meta, "elocation-id")
            elocation_id.text = "e" + str(int(poa_article.manuscript)).zfill(5)

        if poa_article.dates:
            self.set_history(article_meta, poa_article)

        if poa_article.license:
            self.set_permissions(article_meta, poa_article)

        self.set_abstract(article_meta, poa_article)

        # Disabled author keywords from inclusion Oct 2, 2015
        """
        if len(poa_article.author_keywords) > 0:
            self.set_kwd_group_author_keywords(article_meta, poa_article)
        """

        if poa_article.research_organisms:
            self.set_kwd_group_research_organism(article_meta, poa_article)

        if poa_article.funding_awards or poa_article.funding_note:
            self.set_funding_group(article_meta, poa_article)

        return article_meta

    def set_article_datasets(self, parent, poa_article):
        self.set_article_datasets_header(parent)
        self.set_data_availability(parent, poa_article)
        if poa_article.get_datasets("datasets"):
            self.set_major_datasets(parent, poa_article)
        if poa_article.get_datasets("prev_published_datasets"):
            self.set_previously_published_datasets(parent, poa_article)

    def set_article_datasets_header(self, parent):
        sec_title = SubElement(parent, "title")
        sec_title.text = "Data availability"

    def set_data_availability(self, parent, poa_article):
        if poa_article.data_availability:
            tag_name = 'p'
            utils.append_to_tag(parent, tag_name, poa_article.data_availability)

    def set_major_datasets(self, parent, poa_article):
        p_tag = SubElement(parent, "p")
        p_tag.text = "The following datasets were generated:"
        p_tag = SubElement(parent, "p")
        specific_use = "isSupplementedBy"
        # Datasets
        for dataset in poa_article.get_datasets("datasets"):
            self.dataro_num = self.dataro_num + 1
            self.set_dataset(p_tag, dataset, self.dataro_num, specific_use)

    def set_previously_published_datasets(self, parent, poa_article):
        p_tag = SubElement(parent, "p")
        p_tag.text = "The following previously published datasets were used:"
        p_tag = SubElement(parent, "p")
        specific_use = "references"
        # Datasets
        for dataset in poa_article.get_datasets("prev_published_datasets"):
            self.dataro_num = self.dataro_num + 1
            self.set_dataset(p_tag, dataset, self.dataro_num, specific_use)

    def set_dataset(self, parent, dataset, dataro_num, specific_use=None):
        element_citation_tag = SubElement(parent, "element-citation")
        element_citation_tag.set('id', 'dataset' + str(dataro_num))
        element_citation_tag.set('publication-type', 'data')
        if specific_use:
            element_citation_tag.set('specific-use', specific_use)

        if dataset.authors:
            person_group_tag = SubElement(element_citation_tag, "person-group")
            person_group_tag.set("person-group-type", "author")
            for author in dataset.authors:
                collab = SubElement(person_group_tag, "collab")
                collab.text = author

        if dataset.year:
            year = SubElement(element_citation_tag, "year")
            year.text = dataset.year
            year.set("iso-8601-date", dataset.year)

        if dataset.title:
            source = SubElement(element_citation_tag, "source")
            source.text = dataset.title

        if dataset.source_id:
            ext_link_tag = SubElement(element_citation_tag, "ext-link")
            ext_link_tag.text = dataset.source_id
            ext_link_tag.set("ext-link-type", "uri")
            ext_link_tag.set("xlink:href", dataset.source_id)

        if dataset.license_info:
            comment = SubElement(element_citation_tag, "comment")
            comment.text = dataset.license_info

    def set_title_group(self, parent, poa_article):
        """
        Allows the addition of XML tags
        """
        root_tag_name = 'title-group'
        tag_name = 'article-title'
        root_xml_element = Element(root_tag_name)
        new_tag = utils.append_to_tag(root_xml_element, tag_name, poa_article.title)
        parent.append(new_tag)

    def set_journal_title_group(self, parent):
        """
        take boiler plate values from the init of the class
        """

        # journal-title-group
        journal_title_group = SubElement(parent, "journal-title-group")

        # journal-title
        journal_title = SubElement(journal_title_group, "journal-title")
        journal_title.text = self.jats_config.get('journal_title')

    def set_journal_meta(self, parent):
        """
        take boiler plate values from the init of the class
        """
        journal_meta = SubElement(parent, "journal-meta")

        # journal-id
        for journal_id_type in self.jats_config.get('journal_id_types'):
            # concatenate the config name to look for the value
            config_name = "journal_id_" + journal_id_type
            journal_id_value = self.jats_config.get(config_name)
            if journal_id_value:
                journal_id = SubElement(journal_meta, "journal-id")
                journal_id.set("journal-id-type", journal_id_type)
                journal_id.text = journal_id_value
        #
        self.set_journal_title_group(journal_meta)

        # title-group
        issn = SubElement(journal_meta, "issn")
        issn.text = self.jats_config.get('journal_issn')
        issn.set("publication-format", "electronic")

        # publisher
        publisher = SubElement(journal_meta, "publisher")
        publisher_name = SubElement(publisher, "publisher-name")
        publisher_name.text = self.jats_config.get('publisher_name')

    def set_license(self, parent, poa_article):
        license_tag = SubElement(parent, "license")

        license_tag.set("xlink:href", poa_article.license.href)

        license_p = SubElement(license_tag, "license-p")
        license_p.text = poa_article.license.paragraph1

        ext_link = SubElement(license_p, "ext-link")
        ext_link.set("ext-link-type", "uri")
        ext_link.set("xlink:href", poa_article.license.href)
        ext_link.text = poa_article.license.name
        ext_link.tail = poa_article.license.paragraph2

    def set_copyright(self, parent, poa_article):
        # Count authors (non-editors)
        non_editor = []
        for c in poa_article.contributors:
            if c.contrib_type != "editor":
                non_editor.append(c)

        if len(non_editor) > 2:
            contributor = non_editor[0]
            copyright_holder = contributor.surname + " et al"
        elif len(non_editor) == 2:
            contributor1 = non_editor[0]
            contributor2 = non_editor[1]
            copyright_holder = contributor1.surname + " & " + contributor2.surname
        elif len(non_editor) == 1:
            contributor = non_editor[0]
            copyright_holder = contributor.surname
        else:
            copyright_holder = ""

        # copyright-statement
        copyright_year = ""
        date = poa_article.get_date("license")
        if not date:
            # if no license date specified, use the article accepted date
            date = poa_article.get_date("accepted")
        if date:
            copyright_year = date.date.tm_year

        copyright_statement = u'\u00a9 ' + str(copyright_year) + ", " + copyright_holder
        copyright_tag = SubElement(parent, "copyright-statement")
        copyright_tag.text = copyright_statement

        # copyright-year
        copyright_year_tag = SubElement(parent, "copyright-year")
        copyright_year_tag.text = str(copyright_year)

        # copyright-holder
        copyright_holder_tag = SubElement(parent, "copyright-holder")
        copyright_holder_tag.text = copyright_holder

    def set_permissions(self, parent, poa_article):
        permissions = SubElement(parent, "permissions")
        if poa_article.license.copyright is True:
            self.set_copyright(permissions, poa_article)
        self.set_license(permissions, poa_article)

    def set_abstract(self, parent, poa_article):
        """
        Allows the addition of XML tags
        """
        root_tag_name = 'abstract'
        tag_name = 'p'
        root_xml_element = Element(root_tag_name)
        new_tag = utils.append_to_tag(root_xml_element, tag_name, poa_article.abstract)
        parent.append(new_tag)

    def get_aff_id(self, affiliation):
        """
        For each unique author affiliation, assign it a unique id value
        and keep track of all the affs in a dict
        This can be assembled by processing each author aff in succession
        Return the new or existing aff_id dict index
        """
        aff_id = None

        for key, value in self.author_affs.items():
            if self.compare_aff(affiliation, value):
                aff_id = key
        if not aff_id:
            self.author_aff_count += 1
            aff_id = self.author_aff_count
            self.author_affs[aff_id] = affiliation

        return aff_id

    def get_contrib_par_ids(self, poa_article, auth_id):
        """
        In order to set xref tags for authors that link to funding award id
        traverse the article data to match values
        """
        par_ids = []
        for index, award in enumerate(poa_article.funding_awards):
            par_id = "par-" + str(index + 1)
            for contributor in award.principal_award_recipients:
                if contributor.auth_id == auth_id:
                    par_ids.append(par_id)
        return par_ids

    def compare_aff(self, aff1, aff2):
        # Compare two affiliations by comparing the object attributes
        attrs = ['city', 'country', 'department', 'institution']
        for attr in attrs:
            if (getattr(aff1, attr) and getattr(aff2, attr) and
                    getattr(aff1, attr) != getattr(aff2, attr)):
                return False
        return True

    def set_contrib_group(self, parent, poa_article, contrib_type=None):
        # If contrib_type is None, all contributors will be added regardless of their type
        contrib_group = SubElement(parent, "contrib-group")
        if contrib_type == "editor":
            contrib_group.set("content-type", "section")

        for contributor in poa_article.contributors:
            if contrib_type:
                # Filter by contrib_type if supplied
                if contributor.contrib_type != contrib_type:
                    continue

            contrib_tag = SubElement(contrib_group, "contrib")

            contrib_tag.set("contrib-type", contributor.contrib_type)
            if contributor.corresp is True:
                contrib_tag.set("corresp", "yes")
            if contributor.equal_contrib is True:
                contrib_tag.set("equal_contrib", "yes")
            if contributor.auth_id:
                contrib_tag.set("id", "author-" + str(contributor.auth_id))

            if contributor.collab:
                collab_tag = SubElement(contrib_tag, "collab")
                collab_tag.text = contributor.collab
            else:
                self.set_name(contrib_tag, contributor)

            if contrib_type == "editor":
                role_tag = SubElement(contrib_tag, "role")
                role_tag.text = "Reviewing editor"

            if contributor.orcid:
                orcid_tag = SubElement(contrib_tag, "contrib-id")
                orcid_tag.set("contrib-id-type", "orcid")
                orcid_tag.text = "http://orcid.org/" + contributor.orcid

            for affiliation in contributor.affiliations:
                if contrib_type != "editor":
                    aff_id = self.get_aff_id(affiliation)
                    rid = "aff" + str(aff_id)
                    xref_tag = SubElement(contrib_tag, "xref")
                    xref_tag.set("ref-type", "aff")
                    xref_tag.set("rid", rid)
                    xref_tag.text = str(aff_id)
                else:
                    # For editors add an inline aff tag
                    self.set_aff(contrib_tag, affiliation, contrib_type, aff_id=None)

            # Corresponding author xref tag logic
            if contributor.corresp is True:
                self.corresp_count += 1
                rid = "cor" + str(self.corresp_count)
                xref_tag = SubElement(contrib_tag, "xref")
                xref_tag.set("ref-type", "corresp")
                xref_tag.set("rid", rid)
                xref_tag.text = "*"

            # Funding award group xref tags
            for par_id in self.get_contrib_par_ids(poa_article, contributor.auth_id):
                xref_tag = SubElement(contrib_tag, "xref")
                xref_tag.set("ref-type", "other")
                xref_tag.set("rid", par_id)

            # Contributor conflict xref tag logic
            if contributor.conflict:
                rid = "conf" + str(self.conflict_count + 1)
                self.conflict_count += 1
            elif poa_article.conflict_default:
                rid = "conf1"
            else:
                rid = None

            # Contrib conflict xref
            if contrib_type != "editor":
                if rid:
                    xref_tag = SubElement(contrib_tag, "xref")
                    xref_tag.set("ref-type", "fn")
                    xref_tag.set("rid", rid)

        # Add the aff tags
        if contrib_type != "editor":
            for key, value in self.author_affs.items():
                aff_id = "aff" + str(key)
                self.set_aff(contrib_group, value, contrib_type, aff_id)

    def set_name(self, parent, contributor):
        name = SubElement(parent, "name")
        surname = SubElement(name, "surname")
        surname.text = contributor.surname
        given_name = SubElement(name, "given-names")
        given_name.text = contributor.given_name

    def set_aff(self, parent, affiliation, contrib_type, aff_id=None):
        aff = SubElement(parent, "aff")

        if aff_id:
            aff.set("id", aff_id)

        if contrib_type != "editor":
            if affiliation.department:
                department = SubElement(aff, "institution")
                department.set("content-type", "dept")
                department.text = affiliation.department
                department.tail = ", "

        if affiliation.institution:
            institution = SubElement(aff, "institution")
            institution.text = affiliation.institution
            institution.tail = ", "

        if affiliation.city:
            addline = SubElement(aff, "addr-line")
            city = SubElement(addline, "named-content")
            city.set("content-type", "city")
            city.text = affiliation.city
            addline.tail = ", "

        if affiliation.country:
            country = SubElement(aff, "country")
            country.text = affiliation.country

        if affiliation.phone:
            phone = SubElement(aff, "phone")
            phone.text = affiliation.phone

        if affiliation.fax:
            fax = SubElement(aff, "fax")
            fax.text = affiliation.fax

    def do_display_channel(self, poa_article):
        "decide whether to add a display-channel"
        if (poa_article.get_display_channel() and
                poa_article.get_display_channel().strip() != ''):
            return True
        return False

    def do_subject_heading(self, poa_article):
        "decide whether to add subject headings from article_categories"
        if poa_article.article_categories:
            for heading in poa_article.article_categories:
                if heading and heading.strip() != '':
                    return True
        return False

    def do_article_categories(self, poa_article):
        "check whether we will add any article-categories values"
        return bool(self.do_display_channel(poa_article) or self.do_subject_heading(poa_article))

    def set_article_categories(self, parent, poa_article):
        # article-categories
        if self.do_article_categories(poa_article):
            article_categories = SubElement(parent, "article-categories")

            if self.do_display_channel(poa_article):
                # subj-group subj-group-type="display-channel"
                subj_group = SubElement(article_categories, "subj-group")
                subj_group.set("subj-group-type", "display-channel")
                subject = SubElement(subj_group, "subject")
                subject.text = poa_article.get_display_channel()

            if self.do_subject_heading(poa_article):
                for article_category in poa_article.article_categories:
                    # subj-group subj-group-type="heading"
                    if article_category and article_category.rstrip().lstrip() != '':
                        subj_group = SubElement(article_categories, "subj-group")
                        subj_group.set("subj-group-type", "heading")
                        subject = SubElement(subj_group, "subject")
                        subject.text = article_category

    def set_kwd_group_research_organism(self, parent, poa_article):
        # kwd-group kwd-group-type="research-organism"
        kwd_group = SubElement(parent, "kwd-group")
        kwd_group.set("kwd-group-type", "research-organism")
        title = SubElement(kwd_group, "title")
        title.text = "Research organism"
        for research_organism in poa_article.research_organisms:
            parent_tag = kwd_group
            tag_name = 'kwd'
            utils.append_to_tag(parent_tag, tag_name, research_organism)

    def set_kwd_group_author_keywords(self, parent, poa_article):
        # kwd-group kwd-group-type="author-keywords"
        kwd_group = SubElement(parent, "kwd-group")
        kwd_group.set("kwd-group-type", "author-keywords")
        title = SubElement(kwd_group, "title")
        title.text = "Author keywords"
        for author_keyword in poa_article.author_keywords:
            kwd = SubElement(kwd_group, "kwd")
            kwd.text = author_keyword

    def set_funding_group(self, parent, poa_article):
        # funding-group
        funding_group = SubElement(parent, "funding-group")
        for index, award in enumerate(poa_article.funding_awards):
            par_id = "par-" + str(index + 1)
            self.set_award_group(funding_group, award, par_id)
        if poa_article.funding_note:
            funding_statement = SubElement(funding_group, "funding-statement")
            funding_statement.text = poa_article.funding_note

    def set_award_group(self, parent, award, par_id):
        award_group = SubElement(parent, "award-group")
        award_group.set("id", par_id)
        if award.institution_name or award.institution_id:
            self.set_funding_source(award_group, award.institution_id, award.institution_name)
        for award_id in award.award_ids:
            award_id_tag = SubElement(award_group, "award-id")
            award_id_tag.text = award_id
        if award.principal_award_recipients:
            self.set_principal_award_recipients(award_group, award)

    def set_funding_source(self, parent, institution_id, institution_name):
        funding_source = SubElement(parent, "funding-source")
        institution_wrap = SubElement(funding_source, "institution-wrap")
        if institution_id:
            institution_id_tag = SubElement(institution_wrap, "institution-id")
            institution_id_tag.set("institution-id-type", "FundRef")
            institution_id_tag.text = "http://dx.doi.org/10.13039/" + institution_id
        if institution_name:
            institution_tag = SubElement(institution_wrap, "institution")
            institution_tag.text = eautils.entity_to_unicode(institution_name)

    def set_principal_award_recipients(self, parent, award):
        principal_award_recipient_tag = SubElement(parent, "principal-award-recipient")
        for contributor in award.principal_award_recipients:
            self.set_name(principal_award_recipient_tag, contributor)

    def set_volume(self, parent, poa_article):
        if poa_article.volume:
            volume = SubElement(parent, "volume")
            volume.text = str(poa_article.volume)

    def set_pub_date(self, parent, poa_article, pub_type):
        # pub-date pub-type = pub_type
        date = poa_article.get_date(pub_type)
        if date:
            if pub_type == "pub":
                date_tag = SubElement(parent, "pub-date")
                date_tag.set("date-type", pub_type)
                date_tag.set("publication-format", "electronic")
                self.set_dmy(date_tag, date)

    def set_date(self, parent, poa_article, date_type):
        # date date-type = date_type
        date = poa_article.get_date(date_type)
        if date:
            date_tag = SubElement(parent, "date")
            date_tag.set("date-type", date_type)
            self.set_dmy(date_tag, date)

    def set_dmy(self, parent, date):
        day = SubElement(parent, "day")
        day.text = str(date.date.tm_mday).zfill(2)
        month = SubElement(parent, "month")
        month.text = str(date.date.tm_mon).zfill(2)
        year = SubElement(parent, "year")
        year.text = str(date.date.tm_year)

    def set_author_notes(self, parent, poa_article):
        author_notes = SubElement(parent, "author-notes")
        corresp_count = 0
        for contributor in poa_article.contributors:
            if contributor.corresp is True:
                corresp_count += 1
                self.set_corresp(author_notes, contributor, corresp_count)

    def set_corresp(self, parent, contributor, corresp_count):
        # For setting corresponding author tags in author-notes section

        # Look for the first email address in the contributors affiliations for now
        email = None
        for affiliation in contributor.affiliations:
            if affiliation.email:
                email = affiliation.email
                break
        initials = "" + contributor.given_name[0] + contributor.surname[0]
        if email:
            corresp = SubElement(parent, "corresp")
            corresp.set("id", "cor" + str(corresp_count))
            label = SubElement(corresp, "label")
            label.text = "*"
            label.tail = "For correspondence: "
            email_tag = SubElement(corresp, "email")
            email_tag.text = email
            email_tag.tail = " (" + initials + ");"

    def set_history(self, parent, poa_article):
        history = SubElement(parent, "history")

        for date_type in self.jats_config.get('history_date_types'):
            date = poa_article.get_date(date_type)
            if date:
                self.set_date(history, poa_article, date_type)

    def output_xml(self, pretty=False, indent=""):
        publicId = ('-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange ' +
                    'DTD v1.1d3 20150301//EN')
        systemId = 'JATS-archivearticle1.dtd'
        encoding = 'utf-8'
        qualifiedName = "article"

        doctype = xmlio.ElifeDocumentType(qualifiedName)
        doctype._identified_mixin_init(publicId, systemId)

        rough_string = ElementTree.tostring(self.root, encoding)
        reparsed = minidom.parseString(rough_string)
        if doctype:
            reparsed.insertBefore(doctype, reparsed.documentElement)

        if pretty is True:
            return reparsed.toprettyxml(indent, encoding=encoding)
        else:
            return reparsed.toxml(encoding=encoding)


def write_xml_to_disk(article_xml, filename, output_dir=None):
    filename_path = filename
    if output_dir:
        filename_path = output_dir + os.sep + filename
    with open(filename_path, "wb") as fp:
        fp.write(article_xml.output_xml())


def build_article_from_csv(article_id, jats_config=None):
    "build article objects populated with csv data"
    if not jats_config:
        jats_config = parse_raw_config(raw_config(None))
    article, error_count, error_messages = parse.build_article(article_id)
    if article:
        return article
    else:
        LOGGER.warning("the following article did not have enough components and " +
                       "xml was not generated " + str(article_id))
        LOGGER.warning("warning count was " + str(error_count))
        if error_messages:
            LOGGER.warning(", ".join(error_messages))
        return False


def build_xml(article_id, article=None, jats_config=None, add_comment=True):
    "generate xml from an article object"
    if not jats_config:
        jats_config = parse_raw_config(raw_config(None))

    if not article:
        article = build_article_from_csv(article_id, jats_config)
        if not hasattr(article, 'manuscript'):
            LOGGER.info("could not build article for " + str(article_id))
            return None

    article_xml = ArticleXML(article, jats_config, add_comment)
    if hasattr(article_xml, 'root'):
        LOGGER.info("generated xml for " + str(article_id))
        return article_xml
    else:
        return None


def build_xml_to_disk(article_id, article=None, jats_config=None, add_comment=True):
    "generate xml from an article object and write to disk"
    if not jats_config:
        jats_config = parse_raw_config(raw_config(None))
    if not article:
        article = build_article_from_csv(article_id, jats_config)
    article_xml = build_xml(article_id, article, jats_config, add_comment)
    if article_xml and hasattr(article_xml, 'root'):
        filename = jats_config.get("xml_filename_pattern").format(
            manuscript=article.manuscript)
        try:
            output_dir = jats_config.get("target_output_dir")
            write_xml_to_disk(article_xml, filename, output_dir)
            LOGGER.info("xml written for " + str(article_id))
            print("written " + str(article_id))
            return True
        except IOError:
            LOGGER.error("could not write xml for " + str(article_id))
            return False
    LOGGER.error("could not generate xml to disk for " + str(article_id))
    return False
